// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// The Holder Wallet API (the service) provides an interface for managing (personal) digital wallets inside an SVX tenant environment. It facilitates a range of operations including key management, DID management, and credential issuance (receiving) and credential presentation (presenting). The goal is to provide flexibility on how the component is integrated, be it with a mobile or web application, or with a third party service.
///
/// All cryptographic keys are managed by the service (often referred to as custodial key management) in a secure manner and can be used to control identifers (i.e. DIDs), as well as perform key binding in credentials.
///
/// The service facilitates receiving and presenting credentials in accordance to leading standards and specifications in the space. The main focus is on the family of OpenID4VC standards, JWT based credential formats and (optionally) DIDs.
///
/// One instance of the service is able to manage multiple wallets, each of which is a collection of keys, DIDs and associated credentials. This service operates in a trusted environment where its client applications are expected to be trusted as well.
///
/// ## Wallet Management
///
/// It is possible to identify a wallet using an external identifier that matches the client application's user identifier. When providing an external identifier to the create wallet operation, it first searches if an existing wallet exists and returns a reference instead of creating a new instance.
///
/// ## Key Management
///
/// Keys to perform various cryptographic operations are managed within the service and private keys never leave the service.
///
/// The following operations are supported:
///
/// - Create a new key
/// - Delete an existing key
/// - Get a key
/// - Import an existing key
/// - Sign
/// - Sign JWT
/// - Encrypt JWE
/// - Decrypt JWE
///
/// The service supports the following algorithms as defined in RFC7518:
///
/// - ES256
///
/// Keys are stored currently stored in a DB (e.g. Postgres). We plan to add integration with HSM services in the future.
///
/// ## DID Management
///
/// Each wallet is able to manage one or more DIDs. The supported DID methods can be found [here](https://docs.meeco.me/guides/api-guides/dids/did-methods). A DID is typically used as a key binding mechanism in a verifiable credential. The key binding takes place in the issuance process and proof is provided during the presentation process.
///
/// ## Credential Management
///
/// The wallet supports the following credential life cycle operations:
///
/// - Receive a credential
/// - Present a credential
/// - Import an existing credential
///
/// Receiving a credential from an issuer typically involves key binding, which is a process where the service provides a public key or DID to the issuer alongside proof that is controls the key material. When this is completed, the credential, signed by the issuer, is stored in the wallet with a reference to the `kid`.
/// Presenting a credential to a verifier involves sending the credential, alongside proof of the key binding, to the verifier.
///
/// Note that not all credential formats are supported. Please refer to the section on Supported Standards for more information on the different formats that are currently supported.
///
/// ## SVX Integration
///
/// The service is integrated with SVX Platform, which provides a range of services, including:
///
/// - DID operations (create, get)
/// - Credential operations (verify)
/// - Secure data storage (store credentials)
///
/// All wallets belong to one tenant and receive a DID from the SVX Platform where they are registered as end-users. The DID is used to identify the wallet in the SVX Platform.
///
/// Every wallet instance uses its registered DID to authenticate with the SVX Platform. This enables the service to perform operations and store data for each user in its own context. For performance reasons, access tokens are cached for a limited amount of time (this can be configured).
///
/// ## Supported Standards and Specifications
///
/// The Wallet provides support for a variety of specifications and standards with the aim of achieving interoperablity with the wider ecosystem. What follows is a list of the supported specifications and standards grouped per logical domain.
///
/// **Cryptographic Keys**
///
/// - `JWK`: [RFC7517](https://datatracker.ietf.org/doc/html/rfc7517)
/// - `JWA`: [RFC7518](https://datatracker.ietf.org/doc/html/rfc7518)
/// - `JWE`: [RFC7516](https://datatracker.ietf.org/doc/html/rfc7516)
/// - `JOSE`: [JOSE IANA registry](https://www.iana.org/assignments/jose/jose.xhtml)
///
/// **Credential formats**:
///
/// - `jwt_vc_json`: [W3C Verifiable Credentials](https://www.w3.org/TR/vc-data-model/)
/// - `vc+sd-jwt`: [IETF SD-JWT VC](https://datatracker.ietf.org/doc/draft-ietf-oauth-sd-jwt-vc/)
///
/// **Key Discovery**
///
/// - `/.well-known/jwt-vc-issuer` (IETF SD-JWT VC)
///
/// **Credential issuance**:
///
/// - OpenID 4 Verifiable Credential Issuance (draft 13) [(WG Draft)](https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html) [(Editors Draft)](https://openid.github.io/OpenID4VCI/openid-4-verifiable-credential-issuance-wg-draft.html)
///   - Pre-Authorized Code flow
///   - Authorization Code flow
/// - [RFC9126 Pushed Authorization Request](https://www.rfc-editor.org/info/rfc9126)
///
/// **Credential Presentation**
///
/// - OpenID 4 Verifiable Presentation [(WG Draft)](https://openid.net/specs/openid-4-verifiable-presentations-1_0.html)
///
/// ## Authentication and Authorization
///
/// The service doesn't provide authentication or authorization out-of-the-box. It is up to the client to provide this and the service as such is expected to run inside a secure environment and not directly exposed to the outside world.
///
/// A few examples of how the service can be deployed are:
///
/// - Behind an API gateway (e.g. AWS API Gateway, Azure API Management, Krakend)
/// - Behind a Backend For Frontend service facing the outside world
///
/// ## Deployment
///
/// The service can be deployed on-premises or in a cloud environment. It relies on following services:
///
/// - Postgres (application database; keys, dids, credential metadata)
/// - SVX API
/// - Redis (access tokens)
///
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get deployed service version information
    ///
    /// Endpoint to read deployed service version information.
    ///
    /// - Remark: HTTP `GET /version`.
    /// - Remark: Generated from `#/paths//version/get(AppController_getVersion)`.
    public func AppController_getVersion(_ input: Operations.AppController_getVersion.Input) async throws -> Operations.AppController_getVersion.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppController_getVersion.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/version",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppController_getVersion.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VersionDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get deployed service status information
    ///
    /// Endpoint to read deployed service status information.
    ///
    /// - Remark: HTTP `GET /system/status`.
    /// - Remark: Generated from `#/paths//system/status/get(AppController_getSystemStatus)`.
    public func AppController_getSystemStatus(_ input: Operations.AppController_getSystemStatus.Input) async throws -> Operations.AppController_getSystemStatus.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AppController_getSystemStatus.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/system/status",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AppController_getSystemStatus.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.StatusDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Wallet metrics
    ///
    /// - Remark: HTTP `GET /system/metrics/wallets`.
    /// - Remark: Generated from `#/paths//system/metrics/wallets/get(SystemMetricsController_getWalletCounts)`.
    public func SystemMetricsController_getWalletCounts(_ input: Operations.SystemMetricsController_getWalletCounts.Input) async throws -> Operations.SystemMetricsController_getWalletCounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SystemMetricsController_getWalletCounts.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/system/metrics/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SystemMetricsController_getWalletCounts.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletCountsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SystemMetricsController_getWalletCounts.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidDateFilterValueError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SystemMetricsController_getWalletCounts.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InternalServerError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register or find a Wallet
    ///
    /// Register a new Wallet. Optionally use `external_reference`. When a Wallet exists with the given `external_reference`, the existing Wallet information is returned making the operation idempotent.
    /// If `external_reference` is not used a new Wallet is always created.
    ///
    /// Based on the configuration of the component, a Wallet has a default key and DID assigned to it. This key and DID are used to register and authenticate the Wallet with the SVX API.
    ///
    ///
    /// - Remark: HTTP `POST /wallets`.
    /// - Remark: Generated from `#/paths//wallets/post(WalletsController_create)`.
    public func WalletsController_create(_ input: Operations.WalletsController_create.Input) async throws -> Operations.WalletsController_create.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsController_create.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_create.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_create.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_create.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidRequestPayloadError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_create.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.WalletsController_create.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet by ID
    ///
    /// Fetch Wallet information by ID.
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/get(WalletsController_getOne)`.
    public func WalletsController_getOne(_ input: Operations.WalletsController_getOne.Input) async throws -> Operations.WalletsController_getOne.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsController_getOne.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_getOne.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_getOne.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidPathParamError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_getOne.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_getOne.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.WalletsController_getOne.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Wallet by ID
    ///
    /// Deleted Wallet by ID. All information stored inside the Wallet will be deleted as well.
    ///
    /// - Remark: HTTP `DELETE /wallets/{walletId}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/delete(WalletsController_deleteOne)`.
    public func WalletsController_deleteOne(_ input: Operations.WalletsController_deleteOne.Input) async throws -> Operations.WalletsController_deleteOne.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsController_deleteOne.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_deleteOne.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidPathParamError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_deleteOne.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsController_deleteOne.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.WalletsController_deleteOne.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a key for a Wallet
    ///
    /// Create a new cryptographic key associated with the Wallet. Keys are created using the JOSE JWK standard using attribute strings listed in the [JOSE IANA registry](https://www.iana.org/assignments/jose/jose.xhtml).
    ///
    /// Depending on the configuration of the service only certain cryptographic keys are supported.
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/keys`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/keys/post(KeysController_create)`.
    public func KeysController_create(_ input: Operations.KeysController_create.Input) async throws -> Operations.KeysController_create.Output {
        try await client.send(
            input: input,
            forOperation: Operations.KeysController_create.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/keys",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeysController_create.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.KeysController_create.Output.Created.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeysController_create.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidRequestPayloadError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a key for a Wallet
    ///
    /// Return the cryptographic key information for a key associated with a Wallet.
    ///
    /// The information returned contains only header and public attributes of the key, i.e. not the private key information which is kept in the Wallet. Key information is returned in the JOSE JWK standard using attribute strings listed in the [JOSE IANA registry](https://www.iana.org/assignments/jose/jose.xhtml).
    ///
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}/keys/{keyId}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/keys/{keyId}/get(KeysController_get)`.
    public func KeysController_get(_ input: Operations.KeysController_get.Input) async throws -> Operations.KeysController_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.KeysController_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/keys/{}",
                    parameters: [
                        input.path.walletId,
                        input.path.keyId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeysController_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.KeysController_get.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeysController_get.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.KeysController_get.Output.NotFound.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete a key from a Wallet
    ///
    /// - Remark: HTTP `DELETE /wallets/{walletId}/keys/{keyId}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/keys/{keyId}/delete(KeysController_delete)`.
    public func KeysController_delete(_ input: Operations.KeysController_delete.Input) async throws -> Operations.KeysController_delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.KeysController_delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/keys/{}",
                    parameters: [
                        input.path.walletId,
                        input.path.keyId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeysController_delete.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidPathParamError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeysController_delete.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Import a key to a Wallet
    ///
    /// Import an existing cryptographic key to a Wallet using the JOSE JWK notation.
    ///
    /// Depending on the configuration of the service only certain cryptographic keys are supported.
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/keys/import`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/keys/import/post(KeyController_Import)`.
    public func KeyController_Import(_ input: Operations.KeyController_Import.Input) async throws -> Operations.KeyController_Import.Output {
        try await client.send(
            input: input,
            forOperation: Operations.KeyController_Import.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/keys/import",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeyController_Import.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.KeyController_Import.Output.Created.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeyController_Import.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.KeyController_Import.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Sign data with a key from a wallet
    ///
    /// Create a signature based on data provided using a cryptographic key associated with a Wallet.
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/keys/{keyId}/sign`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/keys/{keyId}/sign/post(KeyController_sign)`.
    public func KeyController_sign(_ input: Operations.KeyController_sign.Input) async throws -> Operations.KeyController_sign.Output {
        try await client.send(
            input: input,
            forOperation: Operations.KeyController_sign.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/keys/{}/sign",
                    parameters: [
                        input.path.walletId,
                        input.path.keyId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeyController_sign.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.KeyController_sign.Output.Created.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeyController_sign.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.KeyController_sign.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.KeyController_sign.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.KeyController_sign.Output.NotFound.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a DID for a Wallet
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/dids`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/dids/post(DidController_create)`.
    public func DidController_create(_ input: Operations.DidController_create.Input) async throws -> Operations.DidController_create.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DidController_create.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/dids",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DidController_create.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.DidController_create.Output.Created.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DidController_create.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete a DID from a Wallet
    ///
    /// - Remark: HTTP `DELETE /wallets/{walletId}/dids/{id}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/dids/{id}/delete(DidController_delete)`.
    public func DidController_delete(_ input: Operations.DidController_delete.Input) async throws -> Operations.DidController_delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DidController_delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/dids/{}",
                    parameters: [
                        input.path.walletId,
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.DidController_delete.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credential receive states
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}/receive`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/receive/get(ReceiveController_findAll)`.
    public func ReceiveController_findAll(_ input: Operations.ReceiveController_findAll.Input) async throws -> Operations.ReceiveController_findAll.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ReceiveController_findAll.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/receive",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "order",
                    value: input.query.order
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "order_by",
                    value: input.query.order_by
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_findAll.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialReceiveStatesModelDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_findAll.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.ReceiveController_findAll.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_findAll.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_findAll.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.ReceiveController_findAll.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register credential offer
    ///
    /// Credential offer is a JSON encoded object that the issuer uses to pass information to the wallet and initiate the issuance process.
    /// This endpoint is used to validate, parse and extract the necessary information, leading to the next step in the process, getting an access token.
    ///
    /// For more information on the structure of the credential offer object, see section 4.1 in OpenID4VCI.
    ///
    /// The three supported methods for registering a credential offer are:
    /// - `credential_offer`: Pass the JSON object by value
    /// - `credential_offer_uri`: Pass the JSON object by reference. The service performs a GET request to retrieve the object.
    /// - `credential_offer_endpoint` - Credential Offer sent by the issuer to the wallet credential offer endpoint. It contains a single URI query parameter, either credential_offer or credential_offer_uri
    ///
    /// Note that the options above are mutually exclusive.
    ///
    /// After successfully registering the credential offer, a state is returned. This state is used as an identifier to link subsequent calls to receive endpoints.
    ///
    /// ### Next Step
    ///
    /// To continue the issuance process, call:
    ///
    /// ```POST /wallets/{walletId}/receive/get_access_token```
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/receive`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/receive/post(ReceiveController_create)`.
    public func ReceiveController_create(_ input: Operations.ReceiveController_create.Input) async throws -> Operations.ReceiveController_create.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ReceiveController_create.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/receive",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_create.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialReceiveResponseModelDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_create.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.ReceiveController_create.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get access token
    ///
    /// The get access token endpoint ensures the wallet is able to retrieve a valid access token to go to the next step of actually getting the credential(s).
    ///
    /// Two flows that are supported are:
    /// - Pre-Authorized Code Flow
    /// - Authorization Code Flow
    ///
    /// ### Authorization Code Flow
    ///
    /// Uses the `authorization_code` as defined in RFC6749 to issue access tokens.
    ///
    /// This is usually a two-step process, that involves authentication on the front channel (through a browser window) to be performed by the client.
    ///
    /// In step 1, a call to this endpoint returns the `authorization_url`. This URL is what needs to be opened in a browser window and will authenticate the end-user to the service.
    /// This includes a redirect_uri responsible for receiving and storing the `authorization_code`.
    ///
    /// In step 2, the service, exchanges the code for an access token by calling the Token Endpoint.
    ///
    /// Note that at this point, the wallet initiated Authorization Code flow is not supported.
    ///
    /// ### Pre-Authorized Code Flow
    ///
    /// This flow is used when the issuer has already authenticated and authorized the end-user.
    /// The issuer provides a Pre-Authorized Code in the credential offer which is used to exchange it for an access token in the Token Endpoint.
    /// The Authorization Endpoint is not used in this flow.
    ///
    /// For more information, see section 3.5 in OpenID4VCI.
    ///
    /// ### Next Step
    ///
    /// To continue the issuance process, call:
    ///
    /// ```POST /wallets/{walletId}/receive/get_credential```
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/receive/get_access_token`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/receive/get_access_token/post(ReceiveController_getAccessToken)`.
    public func ReceiveController_getAccessToken(_ input: Operations.ReceiveController_getAccessToken.Input) async throws -> Operations.ReceiveController_getAccessToken.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ReceiveController_getAccessToken.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/receive/get_access_token",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_getAccessToken.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialReceiveGetAccessTokenResponseModelDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_getAccessToken.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get verifiable credential
    ///
    /// Get credential from the issuer and perform key binding. A valid access token is required in order to call this endpoint.
    ///
    /// See section 7 in OpenID4VCI for more information.
    ///
    /// ### Key Binding
    ///
    /// Key binding is performed by providing either
    ///
    /// - `kid`: Public key is presented.
    /// - `did`: DID is presented referencing one of the keys contained in the `verificationMethod` section of the DID document.
    ///
    /// Both methods involve the wallet presenting key proof to the issuer to ensure control over cryptographic key material.
    ///
    /// See section 7.2.1 in OpenID4VCI for more information.
    ///
    /// ### Requesting Multiple Credentials in Sequence
    ///
    /// The `c_nonce` and `c_nonce_expires_in` returned by the issuer allow requesting the same credential, but binding it to different key material.
    /// The service automatically manages these attributes, ensuring the correct `c_nonce` is used, allowing multiple credentials to be retrieved, but with different keys.
    ///
    /// ### Not Supported Options
    ///
    /// Note that the following are not supported by the endpoint
    ///
    /// - `transaction_id`: Part of the deferred issuance flow, allows receiving a credential by referencing a `transaction_id`
    /// - Receiving encrypted credentials
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/receive/get_credential`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/receive/get_credential/post(ReceiveController_getCredential)`.
    public func ReceiveController_getCredential(_ input: Operations.ReceiveController_getCredential.Input) async throws -> Operations.ReceiveController_getCredential.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ReceiveController_getCredential.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/receive/get_credential",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_getCredential.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialReceiveGetCredentialResponseModelDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_getCredential.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get receive credential state
    ///
    /// Get the current state of a receive credential flow.
    ///
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}/receive/{state}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/receive/{state}/get(ReceiveController_findOne)`.
    public func ReceiveController_findOne(_ input: Operations.ReceiveController_findOne.Input) async throws -> Operations.ReceiveController_findOne.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ReceiveController_findOne.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/receive/{}",
                    parameters: [
                        input.path.walletId,
                        input.path.state
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_findOne.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialReceiveStateModelDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.ReceiveController_findOne.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// authorization_code flow Holder Wallet redirect uri 
    ///
    /// `authorization_code` redirect uri that was started via `/receive` endpoint.<br/>
    /// `state` and `code` come as a query parameters.<br/>
    /// `code` is exchanged for the `access_token` so client can call `POST /wallets/{walletId}/receive/get_credential` endpoint right away.
    ///
    ///
    /// - Remark: HTTP `GET /wallets/receive/callback`.
    /// - Remark: Generated from `#/paths//wallets/receive/callback/get(ReceiveController_callback)`.
    public func ReceiveController_callback(_ input: Operations.ReceiveController_callback.Input) async throws -> Operations.ReceiveController_callback.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ReceiveController_callback.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/receive/callback",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 302:
                    return .found(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get presentation states
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}/send`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/send/get(PresentationController_findAll)`.
    public func PresentationController_findAll(_ input: Operations.PresentationController_findAll.Input) async throws -> Operations.PresentationController_findAll.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PresentationController_findAll.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/send",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "order",
                    value: input.query.order
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "order_by",
                    value: input.query.order_by
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PresentationController_findAll.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PresentationStatesResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PresentationController_findAll.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PresentationController_findAll.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PresentationController_findAll.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PresentationController_findAll.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PresentationController_findAll.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register authorization request
    ///
    /// Parse the authorization request URI and get the following information.
    ///
    /// - `client_id`: The Client ID of the verifier.
    /// - `client_id_scheme`: The Client ID scheme of the verifier.
    /// - `client_metadata`: Verifier client metadata.
    /// - `nonce`: Nonce provided by the verifier to be returned in the response
    /// - `presentation_definition`: What credentials the verifier is requesting from the Wallet.
    /// - `redirect_uri`: The redirect URI of the verifier.
    /// - `response_mode`: How to return the response.
    /// - `response_type`: Which parameters to use to return the presentation to the verifier.
    /// - `response_uri`: Where to send the response.
    /// - `verifier_state`: State passed by the verifier to link request and response.
    /// - `meta.protocol_version`: Version of the protocol to be used. Supported values `draft10` and `draft18`. The default value is `draft10`.
    ///
    /// This information informs the Wallet how to process the request and respond to the verifier.
    ///
    /// ## Request Parameters
    ///
    /// The following sections describe in more detail the parameters, their default values and behaviour.
    ///
    /// ### client_id (required)
    ///
    /// Depending on the `client_id_scheme` the Client ID is either the `client_id`, the `redirect_uri` or the `did` of the verifier.
    ///
    /// ### client_id_scheme
    ///
    /// The mechanism to obtain and validate metadata of a verifier beyond that specified in RFC6749.
    ///
    /// Currently supported values are:
    /// - `pre-registered` (default): The verifier is pre-registered with the SVX Platform.
    /// - `redirect_uri`: The redirect URI is the identifier of the verifier. Note that in this case the request MUST NOT be signed.
    /// - `did`: The DID is the identifier of the verifier. Note that in this case the request MUST be signed with a `verificationMethod` property in the DID document. This also requires that verifier metadata is passed using `client_metadata` or `client_metadata_uri`.
    ///
    /// ### client_metadata (required)
    ///
    /// Client metadata, also called verifier metadata in this case can be implemented using static configuration values, as well as employ Dynamic Discovery.
    ///
    /// The static configuration is usually bound to an existing profile, for example.
    ///
    /// - [JWT VC Presentation Profile](https://identity.foundation/jwt-vc-presentation-profile/)
    /// - [HAIP](https://openid.net/specs/openid4vc-high-assurance-interoperability-profile-sd-jwt-vc-1_0-00.html)
    ///
    /// They use specific, custom URL schemes such as `openid-vc` or `haip`. When these are used, values referred to in these profiles should be used as client metadata.
    ///
    /// Each network can define their own set of static configuration values for client metadata.
    ///
    /// The use of fedarations or trust schemes is not yet supported.
    ///
    /// ### nonce
    ///
    /// Nonce to be returned in the response to prevent replay attacks.
    ///
    /// ### presentation_definition (required)
    ///
    /// Expresses which credentials a verifier asks a wallet to present. The syntax to do this should conform to DIF Presentation Exchange specification.
    /// The structure of the definition is validated by a JSON schema associated with the `presentation_definition` schema in the OpenAPI definition.
    ///
    /// It is also possible to use `presentation_definition_uri`. In this case the wallet performs a GET request to the `presentation_definition_uri` and parses the response.
    /// The response is stored in the `presentation_definition` attribute.
    ///
    /// Note that the service does not necessarily support all options defined in the Presentation Exchange specification.
    ///
    /// ### response_mode
    ///
    /// How the response is sent to the verifier. Possible values are
    ///
    /// - `direct_post`: In this mode, the Authorization Response is sent to the Verifier using an HTTPS POST request to an endpoint controlled by the Verifier. The Authorization Response parameters are encoded in the body using the application/x-www-form-urlencoded content type.
    ///
    /// When using `direct_post`, note that the `redirect_uri` must be returned after successfully posting the Authorization Response to the `response_uri`.
    ///
    /// Note that `fragment` is currently not supported.
    ///
    /// ### response_uri
    ///
    /// If the `response_mode` is `direct_post` this is the URI to send the response to.
    ///
    /// ### verifier_state
    ///
    /// Opaque state that can be used to link the request and response. Is returned as the `state` parameter in the Authorization Response.
    ///
    /// ## Use of JAR (RFC9101)
    ///
    /// JAR (RFC9101) is a JWT representation of the request. The JWT is signed with the verifier's private key.
    /// There are two ways to do this.
    ///
    /// - `request`: The `request` parameter is the JWT representation of the request.
    /// - `request_uri`: The `request_uri` parameter is the URL of the request.
    ///
    /// In most cases `request_uri` is used instead of `request` as it is more convenient, especially in situations when a QR code is used to represent the authorization request.
    ///
    /// The JAR contains the necessary information and is fetched, verified and subsequently parsed. See the previous section for more details.
    ///
    /// ## Examples
    ///
    /// Below are some examples of valid authorization requests and how they are parsed.
    ///
    /// ```
    /// openid-vc://?request_uri=https://example.com/oidc/presentations/requests/c63aa3e9-dc7d-4753-9ac8-30bf7add6e4c/jwt&client_id=https://example.com/cb
    /// ```
    ///
    /// This is an example where JAR is used. First, the `request_uri` is used to fetch the request JWT. The JWT is validated and then parsed. The parsed request is stored in the `metadata.request` attribute.
    /// All the required information, except for the `client_id` is fetched from the JWT, validated and stored.
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/send`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/send/post(PresentationController_create)`.
    public func PresentationController_create(_ input: Operations.PresentationController_create.Input) async throws -> Operations.PresentationController_create.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PresentationController_create.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/send",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PresentationController_create.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AuthorizationRequestResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.PresentationController_create.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.PresentationController_create.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Set the credentials to be presented
    ///
    /// Set the credentials to be presented as part of this presentation response.
    ///
    /// Each credential must be linked to an input descriptor from the credential definition.
    /// For credentials that support selective disclosure, there is the possibility to use the `claims_to_disclose` property.
    /// Use object notation to specify which claims to disclose. For example:
    ///
    /// ```
    /// "claims_to_disclose": ["given_name", "address.street_address", "address.locality", "nationalities[0]"]
    /// ```
    ///
    /// If a claim or a nested claim is not found in the credential or it doesn't support selective disclosure, it will be ignored.
    ///
    /// By default, the key ID linked to the credential is used to sign the presentation. The `kid` property can be used to specify another key ID. If no key ID is linked to the credential and none is specified, no signature is added to the presentation.
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/send/set_credentials`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/send/set_credentials/post(SendController_setCredentials)`.
    public func SendController_setCredentials(_ input: Operations.SendController_setCredentials.Input) async throws -> Operations.SendController_setCredentials.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SendController_setCredentials.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/send/set_credentials",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SendController_setCredentials.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PresentationRequestSetCredentialsResponseModelDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SendController_setCredentials.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Submit the presentation response to the verifier
    ///
    /// Generate the presentation response to present the credentials to the verifier.
    ///
    /// Based on the `response_type`, the following parameters are included in the response:
    ///
    /// The response always includes:
    /// - `vp_token`: A single JSON string or array of JSON strings representing the presentation.
    /// - `presentation_submission`: A JSON object containing the mapping between the requested credentials and where to find them in the returned VP token. This follows the DIF Presentation Exchange specification.
    ///
    /// Optionally, the following is also included:
    /// - `id_token`: A single JSON string that proves control of the wallet over key material.
    ///
    /// Depending on the `response_mode` option, the response can be sent to the verifier using an HTTPS POST request or an HTTP redirect.
    ///
    /// In case of `response_mode=fragment` (default), the response is sent via the front channel by opening the `redirect_uri`, which is returned in the response to this request.
    /// This `redirect_uri` includes all the response parameters. Note that this is currently not supported.
    ///
    /// In case of `response_mode=direct_post` or `response_mode=post`, the response is submitted via an HTTPS POST request to the `response_uri`.
    /// In this case, it is expected that a `redirect_uri` is returned in the response to this request.
    /// This `redirect_uri` is also to be opened in the front channel, but is simply used to continue the verification process and not to transmit the response to the verifier.
    ///
    /// The status of this submission can be tracked via the `meta.submission_status` attribute. Note that in case of `response_mode=fragment`, the status is always `success`.
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/send/submit`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/send/submit/post(SendController_submit)`.
    public func SendController_submit(_ input: Operations.SendController_submit.Input) async throws -> Operations.SendController_submit.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SendController_submit.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/send/submit",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SendController_submit.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PresentationRequestSubmitResponseModelDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SendController_submit.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get present credential state
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}/send/{state}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/send/{state}/get(SendController_findOne)`.
    public func SendController_findOne(_ input: Operations.SendController_findOne.Input) async throws -> Operations.SendController_findOne.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SendController_findOne.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/send/{}",
                    parameters: [
                        input.path.walletId,
                        input.path.state
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SendController_findOne.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PresentationStateResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SendController_findOne.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Import credential
    ///
    /// Import an existing credential from a known format into a Wallet.
    ///
    /// Depending on how key binding is performed, the import process associates the credential with the given `did` and/or `kid` if managed by the wallet:
    /// - `did`: The DID used for binding a DID to the credential.
    /// - `kid`: The key ID used for binding the key to the credential.
    ///
    /// If the `did` or `kid` is not managed by the wallet, fields are ignored. They can later be updated with `PATCH /wallets/{walletId}/credentials/{credentialId}`.
    ///
    ///
    /// - Remark: HTTP `POST /wallets/{walletId}/credentials/import`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/credentials/import/post(CredentialsController_import)`.
    public func CredentialsController_import(_ input: Operations.CredentialsController_import.Input) async throws -> Operations.CredentialsController_import.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialsController_import.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/credentials/import",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_import.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialResponseModelDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_import.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_import.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_import.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credentials
    ///
    /// Fetch a paginated list of credentials stored inside the Wallet.
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}/credentials`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/credentials/get(CredentialsController_findAll)`.
    public func CredentialsController_findAll(_ input: Operations.CredentialsController_findAll.Input) async throws -> Operations.CredentialsController_findAll.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialsController_findAll.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/credentials",
                    parameters: [
                        input.path.walletId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "next_page_after",
                    value: input.query.next_page_after
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "per_page",
                    value: input.query.per_page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "order",
                    value: input.query.order
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "format",
                    value: input.query.format
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_findAll.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_findAll.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_findAll.Output.BadRequest.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_findAll.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNotFoundError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_findAll.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_findAll.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credential by ID
    ///
    /// Fetch credential information by ID stored inside the Wallet
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}/credentials/{vcId}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/credentials/{vcId}/get(CredentialsController_findOne)`.
    public func CredentialsController_findOne(_ input: Operations.CredentialsController_findOne.Input) async throws -> Operations.CredentialsController_findOne.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialsController_findOne.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/credentials/{}",
                    parameters: [
                        input.path.walletId,
                        input.path.vcId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_findOne.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_findOne.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidPathParamError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_findOne.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_findOne.Output.NotFound.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_findOne.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_findOne.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Patch credential by ID
    ///
    /// Patches credential stored inside a Wallet.
    ///
    /// Used to update `did` and `kid` fields in the meta data of the credential. Note that the `did` and `kid` need to reference an existing DID and Key Id.
    ///
    ///
    /// - Remark: HTTP `PATCH /wallets/{walletId}/credentials/{vcId}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/credentials/{vcId}/patch(CredentialsController_patch)`.
    public func CredentialsController_patch(_ input: Operations.CredentialsController_patch.Input) async throws -> Operations.CredentialsController_patch.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialsController_patch.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/credentials/{}",
                    parameters: [
                        input.path.walletId,
                        input.path.vcId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_patch.Output.NoContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .noContent(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_patch.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_patch.Output.NotFound.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete credential by ID
    ///
    /// Deletes credential by ID stored inside the Wallet
    ///
    /// - Remark: HTTP `DELETE /wallets/{walletId}/credentials/{vcId}`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/credentials/{vcId}/delete(CredentialsController_remove)`.
    public func CredentialsController_remove(_ input: Operations.CredentialsController_remove.Input) async throws -> Operations.CredentialsController_remove.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialsController_remove.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/credentials/{}",
                    parameters: [
                        input.path.walletId,
                        input.path.vcId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_remove.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidPathParamError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_remove.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_remove.Output.NotFound.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_remove.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_remove.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify credential by ID
    ///
    /// Verifies a verifiable credential by ID that is stored inside the Wallet
    ///
    /// - Remark: HTTP `GET /wallets/{walletId}/credentials/{vcId}/verify`.
    /// - Remark: Generated from `#/paths//wallets/{walletId}/credentials/{vcId}/verify/get(CredentialsController_verify)`.
    public func CredentialsController_verify(_ input: Operations.CredentialsController_verify.Input) async throws -> Operations.CredentialsController_verify.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialsController_verify.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/wallets/{}/credentials/{}/verify",
                    parameters: [
                        input.path.walletId,
                        input.path.vcId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_verify.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CredentialVerificationResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_verify.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InvalidPathParamError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_verify.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_verify.Output.NotFound.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.CredentialsController_verify.Output.InternalServerError.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.CredentialsController_verify.Output.InternalServerError.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .internalServerError(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
